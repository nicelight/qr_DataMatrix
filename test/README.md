Спец, Ты профессионал в области embedded design. Нам необходимо реализовать в проекте кастомный пульт управления двумя устройствами: звуковым усилителем и автомобильной магнитолой. Сейчас я напишу ТЗ.

**Hardware and Firmware**
Кастомный пульт(назовем его PULT) должен дублировать все функции штатного пульта управления звуковым усилителем мощности(назовем его REMO) и дублировать все функции штатного пульта магнитолы(назовем его MAGN).  Наша цель - заменить REMO и MAGN на PULT. 
 PULT будет реализован на базе платы ESP32-S3-DevKitC-1 с подключенным oled экраном и энкодером. Через Serial1(GPIO17, GPIO18) осуществляется связь с усилителем. PULT принимает данные с магнитолы или из UI (енкодер + oled) и передает их на усилитель. 

**data protocol for REMO**
Привожу описание функций и протокола работы REMO. REMO общается с усилителем по UART 8N_1 на скорости 115200. Пакет данных имеет следующие поля: | code | preset | vol | sub | enc | inp | crc |. 
Контрольная сумма CRC рассчитывается по методу crc16/X-25. Вот примеры пакетов, которые REMO отправляет усилителю мощности:
`2 0 FFE2 FFBA 0 0 8CC2` или `2 0 FFD8 FFBA 0 0 621C` или `2 1 1e 28 0 10 16d1`
Вот структура пакета, отправляемого by REMO:
```
// Общий формат пакета управления усилителем звуковой частоты
struct remote_control_packet {
    uint8_t  code;                      // запрос/ответ/ожидание
    uint8_t  preset;                    // выбор пресета (1…4)
    int16_t  master_volume;             // общая громкость
    int16_t  subwoofer_volume;          // громкость сабвуфера
    uint8_t  rotated;                   // флаг поворота энкодера (0/1)
    uint8_t  inp_data; // спдиф-кабель (нибл)&вход (старш. нибл)
    uint16_t crc;                       // CRC-16 от предыдущих байт
};
```
Вот вариации данных в пакете, отправляемом by REMO: 
```
// Типы запросов/ответов
enum remote_control_packet_request {
    REMOTE_CONTROL_REQUEST_READ    = 0x1,
    REMOTE_CONTROL_REQUEST_WRITE   = 0x2,
};

enum remote_control_packet_response {
    REMOTE_CONTROL_RESPONSE_READ    = 0x1,
    REMOTE_CONTROL_RESPONSE_WRITE   = 0x2,
    REMOTE_CONTROL_RESPONSE_MONITOR = 0x3,
};

// Пресеты
enum preset_type {
    PRESET_1 = 1,
    PRESET_2 = 2,
    PRESET_3 = 3,
    PRESET_4 = 4,
};

// Границы регулировок
static const struct volume_limits {
    struct {
        int16_t min;    // –1200  (–120.0 дБ)
        int16_t max;    //    30    (  3.0 дБ)
        int16_t step;   //    10    (  1.0 дБ)
    } master_volume_limits,
      subwoofer_volume_limits = {
        .min  = -160,  // –16.0 дБ
        .max  =   30,  //  3.0 дБ
        .step =   10,  //  1.0 дБ
    };
} volume_limits;

// Флаг поворота энкодера
enum rotated {
    ROTATED_NO  = 0,
    ROTATED_YES = 1,
};

// Работа с байтом INP (inp_data):
// – младший полубайт (0x0F)    = выбор SPDIF-кабеля
// – старший полубайт (>> 4)    = выбор входного канала

static inline uint8_t get_spdif_cable(const struct remote_control_packet *p) {
    return p->inp_data & 0x0F;
}

static inline void set_spdif_cable(struct remote_control_packet *p, uint8_t v) {
    p->inp_data =
        (p->inp_data & 0xF0) | (v & 0x0F);
}

static inline uint8_t get_input_source(const struct remote_control_packet *p) {
    return p->inp_data >> 4;
}

static inline void set_input_source(struct remote_control_packet *p, uint8_t v) {
    p->inp_data =
        (p->inp_data & 0x0F) | ((v & 0x0F) << 4);
}
```  

PULT должен отправлять точно такие же данные усилителю. 

== 

**data protocol for MAGN**
MAGN принимает данные от магнитолы по протоколу UART 8N_1 на скорости 57600. Данные отправляются без CRC. Если 15й байт данных равен 1, то необходимо интерпретировать 16 байт, в котором передается громкость магнитолы. Если 15й байт равен нулю - ничего не делаем.
вот примеры данных от магнитолы:
`153 153 153 238 163 1 0 9   101 0 0 0 8 0 1  0 0 0 0 0 0 0 0 199 170` 
или  
`153 153 153 238 163 1 0 9   100 0 0 0 8 0 0  0 0 1 0 0 0 0 0 198 170` 
или 
`153 153 153 238 163 1 0 9   101 0 0 0 8 0 1  38 0 0 0 0 0 0 225 170`.
Вот как нужно интерпретировать 16й байт громкости: 
66 | 3 
63 | 1 
60 | 0 
58 | -2 
55 | -4 
52 | -6 
51 | -8 
50 | -10 
49 | -12 
48 | -14 
47 | -16 
46 | -18 
45 | -20 
44 | -22 
43 | -24 
42 | -26 
41 | -28 
40 | -30 
39 | -32 
38 | -34 
37 | -36 
35 | -38 
32 | -40 
28 | -42 
23 | -44 
19 | -46 
15 | -48 
12 | -50 
8 | -60 
4 | -90 
0 | -120 

PULT будет получать те же данные от магнитолы через SoftwareSerial(GPIO6, GPIO7), анализировать 16й байт и запоминать его в ОЗУ как текущую громкость, передавая эту громкость на усилитель через Serial1.


**Интерфейс**
Пример отображения на экране:
VOLUME: -120 
SUBWOOFER: +16
INPUT: ANALOG
PRESET: 2

Выбор активного параметра энкодером, активныйпараметр -  слово подчёркнуто, перед словом жирная точка  (VOLUME, SUBWOOFER,INPUT,PRESET).
Нажатие на энкодер - выбор параметра для изменения. 
Все параметры сохраняются в энергонезависимую память.

====== 

Внимательно проанализируй техническое задание, расскажи, как ты его понял и можешь задавать уточняющие вопросы, после чего перейдем к реализации прошивки PULT в среде Arduino IDE.